

\subsection{Simple algorithm}
We implemented the Sieve of Eratosthene because this is a straightforward algorithm.
\subsection{No false positive or negative}
The Sieve of Eratosthene does not lead to any false positive or negative.
\subsection{Use no memory}
Using a regular Sieve will use 1 bit per number, which is in a way exponential. Since we have to write the result in a file we won't bother with that. You'll see further that we didn't consider any of the multiples of 2 or 3 in memory, achieving a gain in memory space of $\frac{1}{2}\times\frac{2}{3} = \frac{1}{3}$.
\subsection{Work on the biggest native integers of the machines}
Since we work with numbers stored as bits in an array, we will use \verb+size_t+ which denote an unsigned integer that can represent the biggest address that can hold in memory, usually a 64 bits number.
\subsection{Speed up factor $m = \# of processors$}
We'll show later that appart from the communication overhead, the work has been split equally between processes.




